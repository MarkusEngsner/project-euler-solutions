# Distinct powers, Problem 29
# Problem description:
# Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
#   22=4, 23=8, 24=16, 25=32
#   32=9, 33=27, 34=81, 35=243
#   42=16, 43=64, 44=256, 45=1024
#   52=25, 53=125, 54=625, 55=3125
# If they are then placed in numerical order, with any repeats removed,
# we get the following sequence of 15 distinct terms:
#   4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

# Task: How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
# https://projecteuler.net/problem=29


from time import time
import cProfile
from math import log, sqrt, ceil



def powerOf(n, baseDict):
    for base in baseDict:
        if base ** 2 > n:  # purely for performance
            return n, 1
        if base ** (baseDict[base] + 1) == n:
            return base, baseDict[base] + 1
    return n, 1


def buildBaseDict(lower, higher):
    ''' both limits are inclusive'''
    baseDict = {}
    rootLimit = ceil(sqrt(higher))
    for i in range(lower, rootLimit + 1):
        base, exponent = powerOf(i, baseDict)
        baseDict[base] = exponent
    highestExp = int(log(higher, 2))    
    return baseDict, highestExp


def buildNewUniques(n, minExp, maxExp):
    ''' builds a dict with exponents as keys 
        and amount of new, unique, powers as values
        n: greatest multiple '''
    uniqueDict = {i: 0 for i in range(1, n + 1)}
    expSet = set()
    for i in range(1, n + 1):
        for j in range(minExp, maxExp + 1):
            exponent = j * i
            if not exponent in expSet:
                uniqueDict[i] += 1
                expSet.add(exponent)
    compoundedDict = {1: uniqueDict[1]}
    for i in range(2, n+1):
        compoundedDict[i] = uniqueDict[i] + compoundedDict[i-1]
    return compoundedDict
    

def getTotal(baseSet, uniqueDict, lower, higher):
    countedNumbers = 0
    result = 0
    for x in baseSet:
        highestExp = int(log(higher, x))
        countedNumbers += highestExp
        result += uniqueDict[highestExp]
    totalNumbers = 1 + higher - lower
    missingNumbers = totalNumbers - countedNumbers
    result += missingNumbers * uniqueDict[1]
    return result


def uniqueCount(lower, higher):
    baseDict, highestExp = buildBaseDict(lower, higher)
    uniqueDict = buildNewUniques(highestExp, lower, higher)
    result = getTotal(baseDict, uniqueDict, lower, higher)
    return result


def runCode():
    start = time()
    low = 2
    high = 1000000
    answer = uniqueCount(low, high)
    end = time()
    print("Limit: {}".format(high))
    print("Answer: {}".format(answer))
    print("Took {} ms".format(round(10 ** 3 * (end - start))))

cProfile.run("runCode()")
#runCode()
# Takes about 0.11 ms on my machine
# And about 300 ms with high = 100000 (tested using timeit)