# Distinct powers, Problem 29
# Problem description:
# Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
#   22=4, 23=8, 24=16, 25=32
#   32=9, 33=27, 34=81, 35=243
#   42=16, 43=64, 44=256, 45=1024
#   52=25, 53=125, 54=625, 55=3125
# If they are then placed in numerical order, with any repeats removed,
# we get the following sequence of 15 distinct terms:
#   4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

# Task: How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
# https://projecteuler.net/problem=29


from time import time
from math import log, sqrt, ceil


def powerOf(n, baseDict):
    for base in baseDict:
        if base ** 2 > n:  # purely for performance
            return n, 1
        if base ** (baseDict[base] + 1) == n:
            return base, baseDict[base] + 1
    return n, 1


def buildBaseDict(lower, higher):
    ''' both limits are inclusive'''
    baseDict = {}
    rootLimit = ceil(sqrt(higher))
    for i in range(lower, rootLimit + 1):
        base, exponent = powerOf(i, baseDict)
        baseDict[base] = exponent
    highestExp = int(log(higher, 2))
    return baseDict, highestExp


def buildNewUniques(n, lower, higher):
    ''' builds a dict with exponents as keys 
        and amount of new, unique, powers as values
        n: greatest multiple '''
    uniqueDict = {i: lower for i in range(1, n + 1)}
    # lower is used for lowerExp to yield the correct value for i = 1
    expSet = set()
    for i in range(1, n + 1):
        lowerExp = int(uniqueDict[1] / i)  # since exp = 1 means every
        newExponents = {x*i for x in range(lowerExp, higher + 1)}
        expSet.update(newExponents)
        uniqueDict[i] = len(expSet)
    return uniqueDict


def getTotal(baseSet, uniqueDict, lower, higher):
    countedNumbers = 0
    result = 0
    for x in baseSet:
        highestExp = int(log(higher, x))
        countedNumbers += highestExp
        result += uniqueDict[highestExp]
    totalNumbers = 1 + higher - lower
    missingNumbers = totalNumbers - countedNumbers
    result += missingNumbers * uniqueDict[1]
    return result


def uniqueCount(lower, higher):
    baseDict, highestExp = buildBaseDict(lower, higher)
    uniqueDict = buildNewUniques(highestExp, lower, higher)
    result = getTotal(baseDict, uniqueDict, lower, higher)
    return result


start = time()
low = 2
high = 100
answer = uniqueCount(low, high)
end = time()
print("Limit: {}".format(high))
print("Answer: {}".format(answer))
print("Took {} ms".format(round(10 ** 3 * (end - start))))

# Takes about 0.05 ms on my machine with high = 10 ** 2
# And about 200 ms with high = 10 ** 5,
# 2600 ms with high = 10 ** 6           (tested using timeit)